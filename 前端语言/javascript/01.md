## javascript基础篇

> ##
> ### 目录
> 1. 函数声明
> 2. 执行环境及作用域链
> 3. 延长作用域链
> 4. 垃圾收集机制
> 5. 私有变量
> 6. 继承的方式以及背后设计的原理
> ##

---

#### 1. 函数声明

在讨论函数声明之前，我们先来聊聊函数的几种创建方式
```
const fn1 = function() {}
function fn2() {}
const fn3 = new Function("return false")
```
以上代码创建了3个函数，分别为fn1、fn2、fn3。其中fn1、fn3是一个匿名函数，fn2是命名函数。

特别的是fn3是通过Function构造函数创建的，通常是不推荐这方式创建函数的，因为需要js解析器解析两遍代码。不过对于理解“函数是对象、函数名是指针”很形象了。

函数名只是一个指向函数对象本身在存储空间（堆内）的一块地址的引用。所以js对于函数来说无法实现函数的重载。例如
```
function fn() {
    return arguments[0] * 2
}

fucntion fn() {
    return arguments[0] * 4
}
```
和下面的代码是等价的
```
let fn = function() {
    return arguments[0] * 2
}
fn = function() {
    return arguments[0] * 4
}
```
本质上都是第二个fn覆盖了第一个fn。

那介绍了函数创建的几种方式以及理解函数名是指针，函数本身是对象以后，我们来引入函数声明的概念。

函数声明就是我们创建命名函数的方式
```
function fn() {}
```

而函数表达式是通过赋值给某个变量，从而让这个变量指向我们的函数对象
```
const fn = function() {}
```
那有啥区别呢？实际上解析器在向执行环境中加载数据的时候，对于函数声明和表达式是有着不同的处理规则。解析器会优先读取函数声明，并使其在执行任何代码之前可用或者叫做可访问吧。而表达式则是要等待解析器执行到表达式所在的那一行时，才会被解释执行。

看例子
```
alert(fn)
alert(a)
function fn() {}
a = function() {}
```
结果是fn正常alert，a会报ReferenceError引用错误，因为表达式还没有执行到a被赋值的那一行。思考以下几个情况的返回值

```
# 情况1
alert(fn)
fn()
alert(a)
let a
function fn() {
    a = function() {
        console.log("im a")
    }
}

# 情况2
alert(fn)
fn()
alert(a)
function fn() {
    a = function() {
        console.log("im a")
    }
}

# 情况3
alert(fn)
fn()
alert(a)
function fn() {
    setTimeout(() => {
        a = function() {
            console.log("im a")
        }
    })
}
```

来解释下函数声明和表达式对于解析器为什么会不同对待的原因是什么，解析器在向执行环境加载数据的时候会一个叫做 **"函数声明提升"** 的过程( $function$ $declaration$ $hoisting$ )，读取并将函数声明添加到执行环境中。js引擎会把函数声明的代码放在源代码树的顶部。

---

#### 2. 执行环境及作用域链

执行环境（execution context）定义了变量或函数有权访问的其他数据，决定了它们的各自行为。环境都有一个对应的**变量对象**（variable object），环境中定义的所有变量和函数都保存在这个对象上。变量对象是无法通过代码访问的，但解析器会在处理数据时用上它。

由于js执行所在的宿主有不同，在浏览器中，最外层的环境，也叫全局环境，它的变量对象被认为是window对象（因为全局创建的变量和函数都塞到window对象里了）。环境（除了全局）中的所有代码被解释执行完之后，环境会被销毁，保存其中的变量和函数定义也都会销毁。全局的是需等到应用程序退出时。

理解了环境之后，再理解作用域就不难了，**作用域是一个环境的变量对象，能力（对该环境数据的访问或使用）生效的区域或者范围边界**。

至此，我们对于以上概念总结一下，并整点名词解释，方便理解后面提到的一些概念。
+   环境(excution context)里都有一个对应的变量对象(variable object)。
>
+   作用域是方便我们理解变量对象而引入的一个概念，它表示变量对象对数据的访问或使用能力所生效的区域或者范围边界。
>
+   执行控制权：js解释器进入一个环境时，会把对代码解释执行的能力赋予当前环境，这个能力被叫做执行控制权。
>
+   活动对象：活动对象（activation object）是变量对象在函数的另一个叫法，是一个意思。初始值只有一个arguments对象。

那我们继续。

函数内部都有属于自己的环境。当执行到函数并进入函数所在的环境时，该环境会被推入一个环境栈中，相应的控制权也移交给该函数。而在函数执行后，栈将其环境弹出，控制权也归还给进入函数环境前的环境。

函数执行的时候，最简单的情况就是一个外环境-全局，一个自己的环境。当函数进行嵌套时
```
function a () {
    const a_vobj = {};
    function b () {
        const b_vobj = {};
        function c() {
            const c_vobj = {};
            ...
        }
    }
}
```
从外向内，或从内向外的会形成一个作用域链条，我们称这个链条为作用域链（scope chain）。作用域链内的每个环境内的变量对象的作用域的生效规则（有点绕嗷。）跟事件冒泡的规则一样（冒泡哦，不是捕获哦，如果你问我冒泡是啥，就当我没说。）。遵循着从内向外的权限扩展。

直接来口诀：内访外yes，外访内no。

搞这个规则，其实是方便环境的变量对象访问数据的有序性。当环境处于函数内是把函数的活动对象作为变量对象，然后执行函数体内部代码，如果遇到操作的变量在当前环境的变量对象找不到的情况，这时候作用域链的作用就发挥了，从内向外的沿着这个链规定的顺序，挨家挨户（每个环境的变量对象）去找要找的变量。找到了最好，没找到抛个引用异常。


以上代码按照上面一大段文字描述来理解执行栈以及作用域链很抽象，可以按下面的代码角度理解（也可能更抽象...）
```
# 全局环境
g_symbol = "";
exec_stack = [];
control_power_cursor = null;
global_env = {
    name: "global",
    env_obj: {},
    code_fragment: "
        a = "foo";
        b = function() {
            let c = "bar";
            console.log("function excution context.")
        }
    "
};
exec_stack.push(global_env);
control_power_cursor = global_env.name;
while(exec_stack.length || control_power_cursor !== null) {
    const env = exec_stack.shift();
    if (env && env.name == control_power_cursor) {
       js_interpreter(env.env_obj, env.code_fragment); 
    }
}

if (g_symbol == "QUIT") {
    do_quit();
}

js_interpreter = () => {
    ...
    const env_obj = arguments[0];
    const frag = arguments[1];
    exec(env_obj, frag, (line, extractInnerFrags = {}) => {
        const { idx: line_idx } = line;
        const extractFragByLine = extractInnerFrags[line_idx];
        if (typeof convertFrag === "function" && extractFragByLine) {
            const { name: envName, frag, env_obj: curt_env_obj } = extractFragByLine;
            const all_env_obj_byScopeChain = {
                ...env_obj,
                ...curt_env_obj
            };
            const curtEnv = {
                name: envName,
                env_obj: all_env_obj_byScopeChain,
                code_fragment: frag
            };
            control_power_cursor = envName;
            exec_stack.push(curtEnv);
        }
    }, (signal, argvs = []) => {
        if (signal == "exec_up_to_down_finished") {
            if (exec_stack.length === 0) {
                control_power_cursor = null;
                g_symbol = "QUIT";
            } else {
                ...
            }
        }
        if (signal == "find_variable_miss_byScopeChain") {
            const [variableName, errorInfo] = argvs;
            throw ReferenceError(
                variableName, "is not defined.",
                "<anonymous>:at:" errorInfo.line, ":", errorInfo.col
            );
        }
    });
    ...
}
```


