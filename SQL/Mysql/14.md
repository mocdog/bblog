## MySQL-事务 笔记-14

> ##
> ### 目录
> 1. 概述
> 2. 事务的创建和存在周期
> 3. 事务的行为
> 4. 事务的性能
> 5. 伪事务
> ##

---

#### 1. 概述

事务是由一条或多条SQL语句组成的单元。在这个单元中每个SQL语句互相依赖。整个单元被看作一个整体，是具有原子性的。如果一个SQL产生错误，整个单元将被回滚，数据返回到执行事务前的状态。

事务适用复杂、且原子性的一组SQL操作来实现的业务场景。

通过InnoDB和BDB类型表，事务能够完全满足事务安全的ACID测试。而MyISAM不支持事务，需要应用伪事务来实现。

**ACID解释**
ACID指出每个事务型RDBS必须遵守的4个属性，即原子性、一致性、孤立性、持久性。

+   原子性： 一组操作看组一个单元，每个成员（一条SQL）都是不可分割的。
+   一致性：无论事务成功或失败，要保证数据的一致。
+   孤立性：事务之间的执行环境的隔离，事务的结果只有在完全执行后才能看到。
+   持久性：即便数据库崩溃，一个被提交的事务仍可在恢复启动后再执行。（通过一条记录事务过程中系统变化的二进制事务日志文件来实现的）通常情况下，InnoDB支持持久性最久，MyISAM部分持久。

---


#### 2. 事务的创建和存在周期

事务建立的前提是在InnoDB存储引擎的表下，所以针对表引擎的设置及修改如下
```
# 设置
create table table_name(...) type=InnoDB|BDB;
# 修改
alter table table_name type=InnoDB|BDB; 
```
alter表可能会导致数据丢失，因此需要在alter前执行备份。

注意如果输入命令后报错内容含“InnoDB feature is disabled”则说明InnoDB表类型没有被开启。需要在MySQL目录下找到my.ini文件，定位skip_innodb选项的位置，然后注释掉，重启MySQL服务即可。

**1.初始化**

```
START TRANSACTION;
```
通过该语句去声明事务，告诉MySQL进入事务模式，之后输入的SQL都是同一个事务的单元。

例如
```
start transaction;
insert into user_tb(name, age) values("joe", 29);
```

**2.提交**

在用户没有提交事务之前，其他用户链接MySQL时，用SELECT语句去查询结果，是不会显示没有提交的事务。体现了事务的孤立性。通过COMMIT命令来进行提交
```
COMMIT
```
一旦执行事务的用户提交之后，其他用户即可查询结果。

**3.撤销（回滚）事务**

```
ROLLBACK
```
回滚的执行代表着``START TRANSACTION``之后的所有SQL操作都将被回滚，所以执行要慎重。如果开启事务但未提交，默认是自动回滚的状态，不会保留任何提交前的操作。

因此可以理解为，``START TRANSACTION``之后到``COMMIT``之前的所有操作都是创建未执行。

**存在的周期**

按照一下过程来表示一个事务的周期
```
初始化
开始事务
操作（增删改）
提交或回滚
新的状态或原有状态
```
事务不支持嵌套功能，当用户在未结束第一个事务之后又开启另一个事务时，前一个事务则会自动提交。

---

#### 3. 事务的行为

存在两个两个控制行为的变量，分别是AUTOCOMMIT和TRANSACTION ISOLCATION LEVEL

**自动提交**

默认是START TRANSACTION之后自动提交，如果想控制提交通过设置
```
SET AUTOCOMMIT=0;
```
来实现。

可以通过2种方式来查看控制是否生效
```
# 方式1
select 对应表看操作是否成功

# 方式2
select @@autocommit;
```

**孤立级**

保证事务的孤立性，采用设置孤立级是很有必要的。提供了4种级别来控制孤立级。
+   SERIALIZABLE 序列化：这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。
>
+   REPEATABLE-READ 可重读：这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 (Phantom Read)。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制(MVCC，Multiversion Concurrency Control)机制解决了该问题。
>
+   READ-COMMITTED 提交后读：这是大多数数据库系统的默认隔离级别(但不是MySQL默认的)。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读(Nonrepeatable Read)，因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。   
>
+   READ-UNCOMMITTED 未提交读：在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读(Dirty Read)。

针对4种孤立级别采用不同的锁类型来实现，如果读取的是同一个数据的话，会产生如下问题：
1. 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。
>
2. 不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
>
3. 幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。

4种孤立级对应产生的问题，如表
|级别|脏读|不可重复读|幻读|
|--|--|--|--|--|
|读未提交|✅|✅|✅|
|读后提交|❌|✅|✅|
|重复读|❌|❌|✅|
|序列化（可串行化）|❌|❌|❌|


修改孤立级
```
# MySQL8之前
# 查看当前孤立级
select @@tx_isolation;
# 设置孤立级
set global transcation ioslation level 级别;

# MySQL8之后
# 查看当前孤立级
select @@transaction_isolation;
# 设置孤立级
set transaction_isolation=级别;
或
set SESSION transaction_isolation=级别;
```
如果想修改事务的孤立级，必须获取SUPER优先权，以便用户顺利执行修改。

---


#### 4. 事务的性能

不同孤立级的事务对系统稳定性和安全性的影响程度也不同。在选择是否使用事务处理数据时，需要依赖以下几个标准来衡量。

+   应用小事务：事务中处理的SQL尽量少，避免各个事务执行过长时间，互相等待从而导致系统性能下降。
>
+   选择合适的孤立级：级别和性能成反比，和安全性成正比。实际情况需要自行取舍。
>
+   死锁的避免：事务的死锁表示，同一时间不同的用户对同一份数据进行更新，互相等待对方释放权限，导致双方处于等待状态。InnoDB表具有检查死锁这一功能。会自动撤销其中一个事务来使锁解开

---


#### 5. 伪事务

除了InnoDB和BDB类型支持事务外，其他的存储类型使用表锁来实现事务，这个实现的过程称为伪事务。

**加锁**
```
lock tables table_name lock_type,...;
```

**解锁**
```
unlock tables;
```

其中lock_type有2个选项，对应2种锁。分别是read（读锁）和write（写锁）。设置了read，除了自己其他人只能读。设置了写锁，除了自己其他人只能写。

lock_type的read的变种``read local``是针对MySQL dump工具而创建的，该参数可以让制定的用户会话执行insert操作。

**实现伪事务**

通过给要操作的表加对应类型的表锁实现。例如
```
# 事务实现
start transaction;
insert into user_tb(name, age) values(...);
commit;

# 表锁
lock tables user_tb read;
insert into user_tb(name, age) values(...);
unlock tables;
```

---

