## 操作系统导论 - PART1 机制：受限直接执行

#### 前言

为了虚拟化CPU，操作系统需要以某种方式以许多任务共享物理CPU，让它们看起来像是同时运行。基本思想很简单，在一个进程运行一段时间，然后运行另一个进程，如此轮换。通过以这种方式时分共享CPU，来实现虚拟化。

构建这样的虚拟化机制的时候存在一些挑战。主要是如下
+   性能
    如何在保证性能的情况下实现虚拟化？
+   控制权
    控制权对于OS很重要，因为OS负责资源管理。如果没有控制权，一个进程可以无限制的接管机器。因此，如何在保持控制权的情况下实现虚拟化？
    
---
 
#### 从直接执行开始

如果不考虑其他因素，想让程序快速的执行，OS开发人员想出了一种方法，我们称之为受限的直接执行（limited direct execution）。这个概念中“直接执行”部分很简单，只需要让程序在CPU上执行即可。因此过程大致如下，当OS希望执行程序运行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码从磁盘加载到内存中，找到入口点（类似main函数之类），跳转到对应的位置，然后开始执行用户的代码。执行完毕后回到内核。

但加上受限，让整个过程变得更加健壮。“受限”是指一个进程必须能够执行I/O和其他一些受限制的操作，但又不让进程完全控制系统。

---

#### 采用受保护的控制权转移

硬件通过提供不同的执行模式来协助操作系统。在用户态（user mode）下，应用程序不能完全访问硬件资源。在内核态（kernel mode）下，操作系统可以访问机器的全部资源。还提供了陷入（trap）内核和从陷入返回（return-from-trap）到用户模式程序的特别说明以及一些指令，让操作系统告诉硬件陷阱表（trap table）在内存中的位置。

---

#### 用户态

在用户态下，运行代码会受到限制，如在用户模式下运行时，进程不能发出I/O请求。这样做会导致处理器引发一场，操作系统可能会终止进程。

---

#### 内核态

在内核态下，操作系统或内核运行的代码可以做它喜欢的事，包括特权操作，如发出I/O请求和执行所有类型的受限指令。

---

#### 陷入和返回陷入

操作系统提供了很多的系统调用(指令)，当然一般用户态的进程无法执行这些系统调用，需要通过特殊的指令进入到内核态。这个过程就是陷入（trap）。当进入内核态，执行完对应的系统调用后，再执行从陷入返回（return-from-trap）的指令。

trap的时候必须保证存储足够的调用者寄存器，以便在操作系统发出从return-from-trap的时候能够正确的返回。如在x86上，处理器会将 程序计数器、标志和其他的一些寄存器推送到每个进程的内核栈（kernal stack）上。当return-from-trap之后，从栈上弹出这些值，以便恢复后继续执行用户态程序。

---

#### 控制权

进程运行的时候，操作系统暂时让出控制权。将控制权转移回操作系统的方式
+   协作方式：等待系统调用
    此方式建立的前提是，操作系统无限信任进程会合理运行。问题是遇到流氓进程，控制权可能永远转移不到操作系统了。
+   非协作方式：操作系统进行控制
    时钟中断重新获得控制权。即使进程以非协议的方式运行，让添加时钟中断（timer interrupt）也让操作系统能够在CPU上重新运行。因此，该功能对于帮助操作系统维持机器的控制权很重要。

---

#### 时钟中断

timer interrupt表示时钟设备可以编程为每隔几毫秒产生一次中断。中断产生时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupt handler）会运行。此时操作系统重新获得CPU的控制权。时钟是在机器启动的时候，操作系统就开启了时钟，这是一项特权操作。

---

#### 保存和恢复上下文

当操作系统获得控制权之后，就要决定是继续运行当前的程序，还是切换到另一个进程。这个决定是由调度程序（scheduler）做出的，它是操作系统的一部分。在决定了进行切换，OS就会执行一些底层代码，即上下文切换（context switch）。

上下文切换的概念是操作系统要做的就是当前正在执行的进程保存一些寄存器的值到他的内核栈，并为即将执行的进程恢复一些寄存器的值到他的内核栈。这样一来，操作系统就可以确保最后执行从trap返回指令时，不会返回到之前运行的进程，而是继续执行另一个进程。

为了保存当前正在运行的进程的上下文，操作系统在执行一些底层汇编代码，来保存通用寄存器、程序计数器以及当前正在运行的进程内核栈指针，然后恢复寄存器、程序计数器并切换内核态。通过切换栈，内核进行切换代码调用时，是一个进程的上下文，返回的是另一个进程的上下文。到此上下文切换完成。

这个过程出现了两种类型的寄存器保存/恢复。第一种是发生时钟中断的时候，运行进程的用户寄存器由硬件隐士保存，使用该进程的内核栈。第二种是在操作系统从A进程切换到B，这种情况下，内核寄存器被软件明确的保存，但这次被存储在该进程的进程结构的内存中。因此，对于外部看，好像是从A进程trap转成了B进程trap一样。

---
#### 时分共享CPU中，进程切换间，需要转移控制权，过程大致如下

在系统引导期间，内核初始化trap table，CPU记住表的位置，然后return-from-trap后正常执行程序，进程初始化的过程会被分配一个节点和内存，硬盘导入内存数据，静态数据存放堆，动态加载入栈。然后当程序需要进行一些系统调用的时候或者触发了系统的时钟中断继而执行了中断程序，之后执行trap指令，进入内核态，将当前程序的程序寄存器及标志压入内核栈，然后操作系统获得控制权，来决定是继续执行当前进程还是通过调度程序来切换其他进程运行，如果切换进程需要进行context switch，之后从切换的进程或者原来进程完成系统调用后，return-from-trap返回用户态，将控制权归还，并将内核栈的数据弹出，程序继续往下执行。

---
