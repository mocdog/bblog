## 操作系统导论 - PART1 机制：受限直接执行

#### 前言

为了虚拟化CPU，操作系统需要以某种方式以许多任务共享物理CPU，让它们看起来像是同时运行。基本思想很简单，在一个进程运行一段时间，然后运行另一个进程，如此轮换。通过以这种方式时分共享CPU，来实现虚拟化。

构建这样的虚拟化机制的时候存在一些挑战。主要是如下
+   性能
    如何在保证性能的情况下实现虚拟化？
+   控制权
    控制权对于OS很重要，因为OS负责资源管理。如果没有控制权，一个进程可以无限制的接管机器。因此，如何在保持控制权的情况下实现虚拟化？
    
---
 
#### 从直接执行开始

如果不考虑其他因素，想让程序快速的执行，OS开发人员想出了一种方法，我们称之为受限的直接执行（limited direct execution）。这个概念中“直接执行”部分很简单，只需要让程序在CPU上执行即可。因此过程大致如下，当OS希望执行程序运行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码从磁盘加载到内存中，找到入口点（类似main函数之类），跳转到对应的位置，然后开始执行用户的代码。执行完毕后回到内核。

但加上受限，让整个过程变得更加健壮。“受限”是指一个进程必须能够执行I/O和其他一些受限制的操作，但又不让进程完全控制系统。

---

#### 采用受保护的控制权转移

硬件通过提供不同的执行模式来协助操作系统。在用户态（user mode）下，应用程序不能完全访问硬件资源。在内核态（kernel mode）下，操作系统可以访问机器的全部资源。还提供了陷入（trap）内核和从陷入返回（return-from-trap）到用户模式程序的特别说明以及一些指令，让操作系统告诉硬件陷阱表（trap table）在内存中的位置。

---

#### 用户态

在用户态下，运行代码会受到限制，如在用户模式下运行时，进程不能发出I/O请求。这样做会导致处理器引发一场，操作系统可能会终止进程。

---

#### 内核态

在内核态下，操作系统或内核运行的代码可以做它喜欢的事，包括特权操作，如发出I/O请求和执行所有类型的受限指令。

---

#### 陷入和返回陷入

操作系统提供了很多的系统调用(指令)，当然一般用户态的进程无法执行这些系统调用，需要通过特殊的指令进入到内核态。这个过程就是陷入（trap）。当进入内核态，执行完对应的系统调用后，再执行从陷入返回（return-from-trap）的指令。

trap的时候必须保证存储足够的调用者寄存器，以便在操作系统发出从return-from-trap的时候能够正确的返回。如在x86上，处理器会将 程序计数器、标志和其他的一些寄存器推送到每个进程的内核栈（kernal stack）上。当return-from-trap之后，从栈上弹出这些值，以便恢复后继续执行用户态程序。