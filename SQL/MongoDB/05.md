## MongoDB - 索引 笔记-05

> ##
> ### 目录
> 1. 概述
> 2. 索引的类型及使用
> 3. 索引的管理
> 4. 内嵌文档和数组的索引使用
> 5. 介绍索引基数
> 6. 使用explain和hint
> 7. 讨论索引使用的场景
> ##

---

#### 1. 概述

数据库索引简单理解为是访问文档数据的一种捷径，假如一个文档数据比喻为一个住宅地址，如果没有索引，我们要找到这个住宅地址需要挨家挨户的打听，但是当我们创建一个索引的时候，就等于拿到了住宅地址的详细信息。

不使用索引的查询成为全表扫描。这样往往效率很低，索引的目的就是提高查询效率。

但索引的弊端是每次写操作(插入、更新、删除)都将耗费更多时间。因为，当数据发生变动时，MongoDB不仅要更新文档，也要更新集合上的所有索引(索引对应的数据地址发生改变)。因此MongoDB限制每个集合上最多拥有64个索引。

---

#### 2. 索引的类型及使用

在介绍索引之前，先介绍查看索引创建进度的方法。因为由于机器性能和集合大小不同，创建索引有可能需要几分钟时间，如果对于ensureIndex的调用没能在几秒内返回，可以另起一个shell，调用 <b>db.currentOp()</b> 辅助函数或者检查mongod日志来查看创建索引的进度。

下面开始介绍索引的类型

<b>单键索引</b>

```
database.collection.ensureIndex({ key: 1 })
```

例如给users集合创建一个基于username的索引
```
> db.users.ensureIndex({ "username": 1 })
```

<b>复合索引</b>

索引的值是按照一定顺序排列的。因此使用索引键对文档进行排序是非常快的。但只有在首先使用索引键进行排序时，索引才有用。

例如
```
> db.users.ensureIndex({ "username": 1 })
> db.users.find().sort({ "age": 1, "username": 1 })
```
这个username的单键索引对这个排序作用不大，此时需要创建复合索引。

用法
```
database.collection.ensureIndex({
    key1: keyDirection,
    key2: keyDirection,
    ...
})
```

+ keyDirection键方向
    可以设置键的方向1或者-1。来组织索引内部的排列顺序。主要影响的是基于 <b>多个</b> 查询条件且 <b>排序</b> 的查询时，方向是比较重要的

MongoDB对于复合索引的使用方式取决于查询的类型。以下三种是主要的方式

+ 点查询(point query)
    传入find的查询文档是以key：value形式的确切值，如果基于key作为复合索引的第一个键，此时如果基于复合索引的其他key对文档排序，因为是有序的，所以无论正序还是逆序都是很快的。
    >
+ 多值查询(multi-value query) 不排序
    多用于范围查询，key在某个范围存在多个值，一般按照索引的顺序进行查询
    >
+ 多值查询 排序
    如果排序的话，查询速度受索引创建从左到右key的顺序影响。接下来针对这个情况细致讨论下。

<section style="background: linear-gradient(45deg, #2f4052, #b2b9be);padding:30px 15px;color:white;border-radius: 8px;margin: 15px 0">
<h1 style="color:white;margin:0">讨论</h1>
我们创建了如下的复合索引
<p style="padding: 15px 0;margin:0">
<code style="background:white !important">
db.col.ensureIndex({ key1: 1, key2: 1 })
</code>
</p>
如果复合索引以上面的顺序创建，那么在多值查询并排序的时候
<p style="padding: 15px 0;margin:0">
<code style="background:white !important">
db.col.find({ key1: { $gt: 10, $lt: 20 } }).sort({ key2: 1 })
</code>
</p>

<p >key1查询出的文档在参照索引表的时候，对于key1来说是有序的，但对于key2来说是无序的（因为key是从左到右顺序互相作为参照的，例如{key,key1,key2}的索引排序是key有序，基于相同key值的key1有序，基于相同key1值的key2有序，以此类推），所以以上面的例子而言还需要在内存对结果进行一步排序才能返回。因此这个查询的效率不如多值查询不排序的那种情况。</p>
那这种情况不是我们希望的，我希望创建索引后，尽可能的提高查询的效率。所以需要引入一种模式的复合索引。
</section>

<b>模式：{"sortKey": 1, "queryCriteria": 1}</b>

针对上面的例子可以修改下索引的使用
```
db.col
.find({ key1: { $gt: 10, $lt: 20 } })
.sort({ key2: 1 })
.hint({ key2: 1, key1: 1 })
```
hint函数后面会介绍，先理解为强制使用的意思。

改动很小，只是把需要排序的key放在了创建索引时的第一个位置。这个改动会让此次查询的排序时间。

从性能上来说如果文档数很大的情况，在使用limit限制m（之前有提到查询速度的影响指标）的之后，性能要远优于未改动前的查询。

<b>右平衡索引 Right Balanced Index</b>

在实际应用程序中，{"sortKey": 1, "queryCriteria": 1}模式的索引通常很有用，因为大多数应用再一次查询中只需要得到查询结果最前面的少数结果，而不是所有结果。而且由于索引在内部的组织形式，这种方式非常易于扩展。

索引的本质是数，最小的值放左边叶子，最大的值放右边叶子。如果一个sortkey从左向右遍历这棵树（不加limit的情况），实际上也花费了很长时间。因此，如果程序需要使用新数据的机会多于老数据，那么Mongo只需要在内存中保留这棵树的最右边的分支，而不用把整颗树放到内存中。类似这样的索引被叫做是<b>右平衡(right balanced)</b>的，应该尽可能让索引右平衡。"_id"就是一个典型的右平衡索引。

<b>覆盖索引 Covered Index</b>

思考一个问题，当一次查询只需要查找索引中包含的字段时，是否有必要获取实际的文档来返回。相信大部分人的想法是没必要，当然mongo也是这么想也这么做的，如果当一个索引包含了用户请求的所有字段时，就认为索引是覆盖了本次查询的。这样的索引被称作覆盖索引。在实际中，我们应该优先使用覆盖索引来保证工作集较小，尤其是搭配右平衡索引一起使用时。

确保查询只使用索引的key就完成应该使用find第二参数传入不必要的键去将其剔除(投射)。

如果在覆盖索引上执行explain(后面会介绍)，"indexOnly"字段的值要设置true。如果一个含有数组的字段上设置索引，那么索引就无法成为覆盖索引了。

<b>隐式索引</b>

复合索引具有双重功能，对于不用的查询可以表现为不同的索引。对于{key1: 1, key2: 1, ... keyn: 1}这样的复合索引，单独分解开来是{key1: 1}, {key1: 1, key2: 1}, ...以此类推，子集的索引也是可以正常使用的。对于用户，这些拆解的索引是隐式存在的，所以也叫隐式索引。

并不是所有的子集索引都可用。只有使用了索引前缀的查询才能从中受益。

<p style="border-bottom:1px dashed #333"></p>

创建索引时候可以指定一些选项，使用不同选项建立的索引会有不同的行为。以下介绍的是通过选项产生的索引变种。

<b>唯一索引</b>
```
database.collection.ensureIndex({ key: 1}, {
    "unique": true
})
```
创建完唯一索引后，再向文档内插入相同的数据时候会出现异常报错。"unique"选项可以针对单键、复合索引设置，实现的行为是一致的。

"_id"就是一个唯一索引。如果一个文档没有对应的键，索引会将其作为null存储。所以，如果对某个键建立了唯一索引，但插入了多个缺少该索引键的文档，会出现插入报错。通俗点说就是创建的时候会生成一个null，再插入的时候传入的也是null，出现重复了就报错了。

有些情况下，一个值可能无法被索引。主要是由于索引储桶(index bucket)的大小有1024字节的限制。值超过了就不被包含在索引里了。而且mongo也不会返回任何错误和警告。也就是超过1kb的键不受唯一索引限制，可以多次插入。

在某些情况下（偏少数），希望直接删除重复的值。可以使用dropDups选项来实现。
```
database.collection.ensureIndex({ key: 1 }, { "unique": 1, "dropDups": 1 })
```
一般情况不用，因为通常我们遇到插入重复的情况，是需要人工判断哪条重复文档（因为重复的是索引key但文档可能还包含其他数据是不同的）是我们要保留的，哪些是该被替换掉的。

<b>稀疏索引</b>

稀疏索引可以理解为，为查询null值的一种特殊处理索引选项。一般情况下查询某个key时，例如
```
db.col.find({ x: { $ne: 2 } })
```
返回结果中包含文档不存在x键的结果（也就是x = null），如果不想让其返回需要用到稀疏索引。

```
database.collection.ensureIndex({key: 1}, {
    "sparse": 1
})
```

当其搭配唯一索引时，会产生有别于唯一索引的查询行为。在插入文档的时候，受限于唯一性约束（设置了唯一索引），不能插入重复的索引值的文档，但是有些时候我们希望，如果索引值不被文档内所包含也就是为null的时候是能插入的。这时候如果索引是稀疏的，则是可以插入的。

通俗理解就是对null值的处理，稀疏的就是宽泛的，唯一的是收窄的，那么如果相对非null进行唯一检测，但对null放宽条件的情况就要结合使用2者。

---

#### 3. 索引的管理

对于索引的创建，只需要一次，重复创建是无效的。数据库所有的信息都存放在system.indexes集合中。这是一个保留集合，不能在其中插入或者删除文档，只能通过提供的辅助函数来操作。

<b>创建索引</b>
```
ensureIndex({ key: 1, ... })
```

<b>查看集合的索引</b>
```
database.collection.getIndexes()
```

返回的索引的结构
```
[{
    "v": 1,
    "key": {
        "_id": 1
    },
    "ns": collectionName,
    "name": "_id_"
}, ...]
```
其中key和name比较重要用于标识索引。返回的索引都已用在hint、min、max以及其他需要指定索引的地方。"v"字段只在内部使用，用于标识索引版本，如果不包含v字说明是老版本保存的索引可以删除重新创建。

<b>标识索引</b>

索引默认名称形式如 keyname1_dir1_keyname2_dir2,可以通过第二个参数对象传入name选项来指定索引名称。
```
db.col.ensureIndex({ key1: 1, key2: 2 }, { name: indexAlisName })
```

<b>删除索引</b>
```
dropIndex("index_name")
```
index_name是getIndexes返回的索引的name。

<b>后台创建</b>

创建索引是一项比较耗费资源的事情，默认情况下创建期间会阻塞所有的读写请求(加锁)，知道创建完成才释放。如果希望不阻塞读写的进行创建可以使用background选项。
```
db.col.ensureIndex({ key1: 1, key2: 2 }, { background: 1 })
```
但是后台创建的过程是受读写的影响的，也就是读写来的时候不阻塞，但也没法继续创建索引，创建过程是暂停的。

另外一个小技巧是在已有的文档创建索引会比空文档创建索引再插入快一些。（每插入一次就要同步一次，想想就耗时）

---
#### 4. 内嵌文档和数组的索引使用

Mongo允许深入文档内部，对嵌套字段和数组建立索引。嵌套对象和数组字段可以与复合索引中的顶级字段一起使用，使用的行为同其他非嵌套索引一致。

<b>对嵌套文档建立索引</b>
```
db.col.ensureIndex({ "objectKey.subkey[.subkey...]": 1 })
```

例如
```
> db.users.find({ "username": "joe" })
{
    username: "joe",
    hobbitMoive: {
        favoritest: {
            name: "xx",
            detail: ...
            ...
        },
        ...
    }
}

# 针对hobbitMoive经常查询的favoritest字段建立索引
db.users.ensureIndex({ "hobbitMoive.favoritest": 1 })
```

对嵌套文档本身建立索引，和给嵌套文档的键建立索引是不同的。本身建立的索引只在进行全匹配查询的时候才会生效，而诸如"find({ "key.subkey": value })"这类的不生效。后者应用上面的方式创建索引来查询嵌套的文档。

<b>对数组建立索引</b>

对数组建立索引旨在快速查询数组中某些满足条件的文档。

```
# 第一种方式: 为每个元素建立一个索引条目, arrayKey有多少条，就创建多少个索引
db.col.ensureIndex({ "arrayKey.key": 1 })

# 第二种方式：为特定的某个元素建立索引
db.col.ensureIndex({ "arrayKey.[index].key": 1 })
```

方式1比较常用，但在使用的时候，尽量保证一个索引中数组字段至多有1个，如果过多，会导致索引条目过大，资源被耗尽。

<b>多键索引</b>

上述例子中对于数组以方式1建立的索引被叫做多键索引（multikey index）。可以从explain输出中看到"isMultiKey"字段来标识是否是多键索引，如果是则值为true否则false。一个索引被标记为多键索引后，就不可逆了，要想还原，只能删除重新创建索引。多键索引可能会比其他非多键索引慢一些。可能会有多个索引条目指向同一个文档（文档数组内元素的值相同），Mongo需要在返回结果前去除重复内容。

---

#### 5. 介绍索引基数

索引基数是说键对应值的数量。譬如性别的基数就是2，无非男女。但像username的基数就可能有很多。索引性别是低基数，姓名是高基数。

一般，应该在高基数键建立索引(索引能将很宽泛的搜索范围迅速缩到一个很窄的区间，但低基数没多大作用)，或者至少应该把高基数的键放在低的左侧（前面）。
```
db.col.ensureIndex({ highCardKey: 1, lowCardKey: 1 })
```

---
#### 6. 使用explain和hint

<b>explain函数</b>

结合find使用，它提供了大量与查询有关的信息。对于速度较慢的查询来说，是一个重要的诊断工具之一。通过函数的返回结果可以知道查询使用了哪个索引，以及如何使用的。对于任意查询，都可以在最后的链式调用explain函数。

常见的explain输出有2种。分无索引的查询和有索引的查询。后面还会介绍分片的输出，是多个explain的聚合。

如果一个查询不带索引说明其使用的是基本游标(BasicCursor)。带索引说明说明其使用的B树游标（BtreeCursor）一些特殊的索引如地理空间索引使用的是自己类型的游标。

explain返回的几个重要字段介绍说明
|字段|说明|
|--|--|
|cursor|游标类型，通过类型也能知道本次是否带索引，以及带的是什么类型的索引，例如BtreeCursor、reverse、multi等|
|isMultiKey|是否使用了多键索引|
|n|查询返回的文档数量|
|nscannedObjects|MongoDB按照索引指针去磁盘上查找实际文档的次数。如果查询文档的字段不在索引内，则需要查找索引指向的文档本身|
|nscanned|使用索引的话，表示检索的索引条目，否则是文档条目|
|scanAndOrder|在内存上是否对结果排序了|
|indexOnly|是否用索引就完成查询，即覆盖索引|
|nYields|因为写入请求而中断的次数|
|millis|查询耗时（毫秒）|
|indexBounds|描述索引的使用情况，给出了索引的遍历范围|
|allPlans|使用的查询计划详细|

<b>hint函数</b>

如果查询的时候，符合查询条件的索引（一般这种情况出现在多条件，复合索引下）有多个例如
```
{ key1: 1, key2: 1 } 和 { key2: 1, key1: 1 }
```

这时候查询没有带排序的话，默认是根据查询效率自动选择索引，如果查询条件中的key1是范围，key2是精确值，那优先用的是第二个（精确值在索引存储块上是连续的，比东一块西一块的找要快），反之用第一个索引。如果想强制用某个索引的话。使用hint函数
```
database.collection.find().hint({ key1: 1, ... })
```

<b>查询优化器</b>

Mongo查询优化规则是如果一个索引能精确匹配一个查询，那么就用这个。否则会有几个索引都适合的情况下，是并行的在跑，先返回100个结果的就是胜利者(先到先得FCFS),其他的会被中止。然后本次查询计划会被缓存，接下来的查询都会用它，直到集合数据发生了比较大的变动。优化器会重新挑选可行的计划。

建立索引或每执行1000次查询后，都会重新评估查询计划。

---

#### 7. 讨论索引使用的场景

<b>何时不应该用索引</b>

一般来说，提取较小的子数据集时，索引非常高效，而提取较大的数据集乃至整个集合的时候不用最好。

如果查询需要返回集合大于等于30%的文档，就应该舍弃索引查询了。

影响索引效率的属性
|适用|不适用|
|--|--|
|集合大|集合小|
|文档大|文档小|
|选择性查询|非选择性查询|

可以使用$natural强制数据库做全表扫描。
```
database.collection.find().hint({ "$natural": 1 })
```
$natural指定文档按照磁盘上的顺序排列。一个活跃的文档，会经常的进行插入删除，磁盘上会留下很多空白的位置来去填充适合大小的新文档，对于这种来说意义不大。但对于那些只进行插入或者更新操作较少的文档有意义的。

<b>$操作符如何使用索引</b>

有一些查询完全无法使用索引，也有一些查询能够比其他查询更高效的使用索引。

1.低效率操作符
```
$where $exists $ne $not $nin
```
这些操作符对于索引的时候依赖不大，因为像\$exists、\$nin 、\$ne这些都需要全文档扫描才能返回结果。

2.范围

创建复合索引时，将精确查找的key放在索引的前面，范围的放在后面。要比两个范围的索引在查找时快很多。

3.or查询

MongoDB每次查询只能使用一个索引，但\$or是个例外，它会针对查询条件的每个字条件都匹配对应的索引（前提是对应key的索引存在）。然后执行多次查询，最后将查询结果聚合后返回，通常来说执行两次查询再将结果合并的效率不如单词查询快。

一般情况下不得不使用or查询，要切记，MongoDB需要检查每次查询的结果集并从中移除重复的文档，那某些文档会被or的子句多次命中。

PS：使用in查询无法控制返回文档的顺序（除非进行排序）
