## 操作系统导论

## 开篇 笔记-01

本系列操作系统导论是基于雷姆兹和安德莉亚写的《操作系统导论》一书为知识点的参照。笔记是以单个概念的方式抛出，前后可能不存在强的关联性。对于特定知识点检索起来很方便，但不利于对整体知识点做串联或是图谱一类。（本书的一些代码示例，会放在code_demo目录下，通过笔记序号做参照）

01笔记主要是简单介绍些基本概念以及本书重点关注的一些问题。

---

#### 程序运行时会发生什么

一个正在运行的程序会做一件非常简单的事情：执行指令。

处理器从内存中获取(fetch)一条指令，然后执行(excute)。然后如此往复，直到程序最终完成。这样，就描述了冯诺伊曼计算模型的基本概念。

---

#### 什么是操作系统

有一类软件负责让程序运行变得更加容易，甚至允许你同时运行多个程序，允许程序共享内存，让程序能够与设备交互，以及其他类似的有趣工作。这类软件称为 **操作系统**。因为它们确保系统既易于使用又正确高效的运行。

---

#### 什么是虚拟化

**虚拟化**：操作系统想要实现让程序运行起来更加容易以及让程序实现各种交互和有趣的工作，需要利用一种通用的技术，我们称之为**虚拟化**（virtualization）。也就是说操作系统将物理资源（如处理器、内存或磁盘）转换为更通用、更强大且更易于使用的虚拟形式。因此我们有时候将操作系统称为虚拟机。

为了让用户可以告诉操作系统做什么，从而利用虚拟机的功能，例如访问文件，分配内存啥的，操作系统还提供了一些接口，供开发者调用，典型的操作系统会提供几百个**系统调用**(system call)，让应用程序调用。由于操作系统提供这些调用来运行程序、访问内存和设备，并进行其他相关操作，我们有时也说操作系统为应用程序提供了一个标准库。

因为虚拟化，让许多程序运行从而共享CPU，让许多程序可以同时访问自己的指令和数据从而共享内存，让许多程序访问设备从而共享磁盘。所以操作系统有时被称为资源管理器。每个CPU、内存和磁盘都是系统的资源，操作系统扮演者管理者的角色。目的是分配好（以高效或公平）这些程序对资源的使用。

---

#### 关注点1:什么是CPU虚拟化

例子源码在"code_demo/01/cpu.c"

编译
```
gcc -o cpu cpu.c -Wall
```

传参执行
```
./cpu "A"
```
以上代码执行结果是一直有A打印，貌似挺无聊的。

再执行以下代码
```
./cpu A &; ./cpu B &; ./cpu C &;
```
这时打印的结果会出现ABC穿插着输出在屏幕上。尽管我们只有一个处理器，但似乎3个程序在同时运行！

事实证明在硬件的帮助下，操作系统负责提供这种拥有非常多的虚拟CPU的假象。从单个CPU转换为看似无限数量的CPU，从而让许多程序看似同时运行，这就是所谓的虚拟化CPU。

---

#### 关注点2:什么是内存虚拟化

每个进程访问自己的私有虚拟地址空间（virtual address space）有时称为地址空间，address space。操作系统以某种方式映射到机器的物理内存上。一个正在运行的程序中的内存引用不会影响其他进程的地址空间。对于正在运行的程序，拥有自己的物理内存。实际情况是，物理内存是由操作系统管理的共享资源。

---

#### 关注点3:并发性

并发这个术语可以用来指代一系列问题。这些问题在同时处理很多事情时出现且必须解决。并发问题首先出现在操作系统本身，例如同时处理多个正在运行的程序（进程）等。其次出现在现代的多线程程序也存在同样问题。

本书主要在意的关键问题是如何构建正确的并发程序，如果同一个内存空间中有很多并发执行的线程，如何构建一个正确的程序？操作系统需要什么原语？硬件应该提供哪些机制？我们如何利用它们来解决并发问题？。

---

#### 关注点4:持久性

系统内存中，数据易丢失，因为像DRAM这样的设备以易失的方式存储数据。如果断电或系统崩溃，那么内存中的数据都会丢失。因此需要硬件和软件来持久的存储数据。

本书主要在意的关键问题是如何持久的存储数据，文件系统是操作系统的一部分，负责管理持久数据。持久性需要哪些技术才能实现？需要哪些机制和策略才能高效的实现？面对硬软键的故障，可靠性如何实现？。

---

#### 操作系统的设计目标

现在你已经了解了操作系统实际上做了什么：它取得CPU、内存或磁盘等物理资源（resources），并对它们进行虚拟化（virtualize）。它处理与并发（concurrency）有关的麻烦且棘手的问题。它持久地（persistently）存储文件，从而使它们长期安全。鉴于我们希望建立这样一个系统，所以要有一些目标，以帮助我们集中设计和实现，并在必要时进行折中。找到合适的折中是建立系统的关键。主要目标如下：

+   建立一些抽象（abstraction），让系统方便和易于使用。

+   提供高性能（performance）也就是最小化操作系统的开销（minimize the overhead）。
+   在应用程序之间以及在OS和应用程序之间提供保护（protection）。
+   高度可靠性。

还有一些目标，例如在我们日益增长的绿色世界中，能源效率（energy-efficiency）非常重要；安全性（security）（实际上是保护的扩展）对于恶意应用程序至关重要，特别是在这高度联网的时代。随着操作系统在越来越小的设备上运行，移动性（mobility）变得越来越重要。

根据系统的使用方式，操作系统将有不同的目标，因此可能至少以稍微不同的方式实现。但是，我们会看到，我们将要介绍的关于如何构建操作系统的许多原则，这在各种不同的设备上都很有用。
