## 操作系统导论 - 调度：多级反馈队列


前面提到过的几种调度策略，按照设计目的性分为，针对优化周转时间的SJF、STCF和针对优化响应时间的RR。

#### MLFQ调度算法

MLFQ（Multi-level Feedback Queue，多级反馈队列）中有许多独立的队列，每个队列有不同的优先级。任何时刻，一个工作只能存在于一个队列中，MLFQ总是优先执行优先级较高的工作。

MLFQ调度策略的关键是如何设置优先级。MLFQ没有为每个工作指定不变的优先级，而是通过观察不同的工作行为来调整它的优先级。


MLFQ遵循的基本规则
1.  如果A的优先级 > B的优先级，运行A
2.  如果A的优先级 = B的优先级，轮转运行A、B
3.  工作进入系统时，放在最高优先级（最上层队列）
4.  一旦工作用了在某层中的时间配额，无论主动放弃多少次CPU，降低其优先级（移至到下一个队列中）
5.  如果工作在其时间片以内主动释放CPU，则优先级不变。

MLFQ的问题：
1.  饥饿问题。如果运行时间短的交互工作过多会导致长时间不断占用CPU，导致长工作（CPU密集计算）永远无法获得CPU。
2.  程序会控制进程，让其在时间片用完之前调用IO操作，来欺骗调度程序，认为其工作是一个短工作，从而一直保持在高优先级
3.  程序在不同时间的形态是不同的表现。一个计算密集的进程在某个时间段可能表现为一个交互型的进程。

因此可以通过下面的规则来提升优先级
6.  经过一段时间S后，就将系统中所有工作重新加入最高优先级队列。

随之产生的问题就是如何设置具体且合适的S值。可以提供一组默认配置表来决定进程在其生命周期中如何调整优先级，每层的时间片多大，以及多久提升一个工作的优先级【ADoo】。管理员通过这些表，让调度程序的行为方式不同。

某些MLFQ调度程序没有用表，甚至没有用到上面提到的几个规则，有些是采用数学公式来调整优先级。例如，FreeBSD调度程序，会基于当前进程使用了多少CPU，通过公式计算某个工作的当前优先级。另外，使用量会随时间衰减，这提供了期望的优先级提升，但与上面描述的方式不同。

因此，MLFQ调度算法是通过表现来动态调整其优先级，将不同表现的工作进程按照某种规则或算法，来放置在不同的优先级队列中执行。
