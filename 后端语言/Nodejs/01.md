## Nodejs-异步编程 笔记01

> ##
> ### 目录
> 1. 前言
> 2. 函数式编程
> 3. 异步编程的优势与难点
> 4. 异步编程解决方案
> 5. 异步并发控制
> ##

---

### 前言

Nodejs是首个将异步大规模带到应用层面的平台，从内在运行机制到API的设计，无不透露着异步的气息。而异步I/O在应用层面并不是十分流行，其原因是异步编程在流程控制上，业务表达并不太适合自然语言的线性思维习惯。较少的人能适应直接面对事件驱动来进行编程。熟悉它的主要是GUI开发者，如前端工程师或GUI工程师。

---
#### 2. 函数式编程

函数式编程作为异步编程的基础。要提前重点介绍一下。在js中函数作为一等公民，使用上十分自由，无论调用它，作为参数、返回值都可以。

函数的灵活性是js比较吸引人的地方之一。它与古老的Lisp语言很有渊源。js诞生前，作者借鉴了Scheme语言，它是Lisp的派生语言。吸收了函数式编程的精华，将函数作为一等公民的典型案例。

#### 2.1 高阶函数

将函数作为参数或是返回值的函数。
```
function higherOrderFunction(fn) {
    return function() {
        return fn();
    }
}
```
对于程序编写，高阶函数则比普通的函数灵活很多。除了通常意义的函数调用以外，还形成了一种后续传递风格（Continuation Passing Style）的结果接收方式，而非单一的返回值。
```
function hof(x, fn) {
    return fn(x);
}
```
这个例子，fn传入的不同，返回的结果也不同。js中一个典型的例子就是sort函数。传入的处理函数不同，得到的结果也不同。
```
let arr = [1,2,3];
// 升序
arr.sort((a1, a2) => return a2 - a1);
// 降序
arr.sort((a1, a2) => return a1 - a2);
```
在Node中，事件的处理方式正是基于高阶函数的特性来完成的
```
var emitter = new events.EventEmitter();
emitter.on("event_foo", () => {
    // TODO
})
```
根据传入的事件处理函数不同，可以灵活的处理业务逻辑。一些复杂的业务逻辑的解耦也是得益于高阶函数。

高阶函数在js中比比皆是，如forEach、every、filter等

#### 2.2  偏函数用法

通过指定部分参数来产生一个新的定制函数的形式就是偏函数。例如
```
# 未使用偏函数
let toString = Object.prototype.toString;
let isString = (obj) => {
    return toString.call(obj) === "[object String]";
}
let isArray = (obj) => {
    return toString.call(obj) === "[object Array]";
}

# 思考：如果我们需要判断的类型增加一个，就要重新定义个对应的类型判断函数，这样合理吗？

# 偏函数
let isType = (type) => {
    return (obj) => {
        return Object.prototype.toString.call(obj) == `[object ${type}]`;
    }
}
const isString = isType("String");
const isFunction = isType("Function");
```

偏函数应用在异步编程中是十分常见的。著名类库Underscore提供的after方法就是偏函数的应用。
```
_.after = (times, func) => {
    if (times <= 0) {
        return func();
    }
    return function() {
        if (--times < 1) {
            return func.apply(this, arguments);
        }
    }
}
```

---
#### 3. 异步编程的优势与难点

曾经的单线程同步I/O是为了满足开发人员的线性思维。但随着业务的复杂度升级，摆在开发者面前的问题是性能。由于同步加上I/O调用缓慢，导致应用层面CPU与IO无法重叠进行。

因此提升性能首先想到的是多线程解决，但多线程随之带来的OS调度多线程的上下文切换开销，实际编程中的锁、同步问题，也让开发人员十分头疼。另一个解决方案是通过C/C++调用OS底层接口，自己完成异步IO，这样能达到高性能。但开发和调试的门槛十分高。

Node利用js及其内部异步库，将异步直接提升到业务层面，是一种创新。

#### 3.1 优势

基于事件驱动的非阻塞IO模型，这个是Node带来最大的特性。灵魂的所在。

利用事件循环的经典调度在很多地方都存在应用。最典型的是UI编程，如iOS应用开发。

Node为了解决编程模型中的IO阻塞带来的性能问题时，采用了单线程模型，导致了Node更像是处理一个IO密集的高手，而CPU密集型则取决于调度算法的能耐如何。

由于事件循环模型需要应对海量请求，这些请求同时作用在单线程上，这时就需要防止任何一个计算耗费过多的CPU时间片。至于是计算密集型，还是IO密集型，只要不影响异步IO的调度，就不构成问题。建议对CPU耗时不要超过10ms，或者将大量的计算分解成诸多少量的计算，通过``setImmediate()``来去调度。只要合理利用Node的异步模型和V8引擎的高性能，就可以充分发挥CPU和IO资源的优势了。

#### 3.2 难点

**难点1:异常处理**
```
try {
    async(callback);
} catch (err) {
    // TODO ERROR handle
}
```
async调用的时候，同一个执行环境内的错误是可以被捕获到的，但是由于async方法调用后，callback被保存起来，在下一次tick的时候执行，因此是捕获不到callback内的抛出的异常的。

因此Node在处理异常上形成了一种约定，将异常作为回调函数的第一个参数，如果返回空值则表示没有异常。
```
async((err, ret) => {
    if (err !== null) {
        // TODO ERROR handle
    }
    // TODO SUCCESS handle
})
```

在我们自行编写的异步方法上，也需要去遵循：
+   必须执行调用者传入的回调函数
+   正确传递回异常，供调用者判断

另一个容易发生的错误是try语句块包含了不属于要捕获的代码段
```
# 本段代码原本是想在doSentence1出错误的时候执行doSentence2并传入err，
# 如果没出错就继续执行不带参数的doSentence2。
# 但是如果doSentence2执行异常，被捕获到了也会进入catch
# 导致了doSentence2执行了两次，不满足我们的预期
try {
    doSentence1();
    doSentence2();
} catch(err) {
    doSentence2(err);
}

# 正确处理是
try {
    doSentence1();
} catch(err) {
    doSentence2(err);
}
doSentence2();
```

**难点2:函数嵌套过深**

---
#### 4. 异步编程解决方案



---
#### 5. 异步并发控制



---