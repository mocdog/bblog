## javascript基础篇

> ##
> ### 目录
> 1. 函数声明
> 2. 执行环境及作用域链
> 3. 延长作用域链
> 4. 垃圾收集机制
> 5. 私有变量
> 6. 继承的方式以及背后设计的原理
> ##

---

#### 1. 函数声明

在讨论函数声明之前，首先我们要知道函数总共有几种创建的方式，来看以下代码
```
const fn1 = function() {}
function fn2() {}
const fn3 = new Function("return false")
```
以上代码创建了3个函数，分别为fn1、fn2、fn3。其中fn1、fn3是一个匿名函数，fn2是命名函数。

fn3是通过Function构造函数创建的，通常是不推荐这方式创建函数的，因为需要js解析器解析两遍代码。不过对于理解“函数是对象、函数名是指针”很形象了。

函数名只是一个指向函数对象本身在存储空间（堆内）的一块地址的引用。所以js对于函数来说无法实现函数的重载。例如
```
function fn() {
    return arguments[0] * 2
}

fucntion fn() {
    return arguments[0] * 4
}
```
和下面的代码是等价的
```
let fn = function() {
    return arguments[0] * 2
}
fn = function() {
    return arguments[0] * 4
}
```
本质上都是第二个fn覆盖了第一个fn。

那介绍了函数创建的几种方式以及理解函数名是指针，函数本身是对象以后，我们来引入函数声明的概念。

函数声明就是我们创建命名函数的方式
```
function fn() {}
```

而函数表达式是通过赋值给某个变量，从而让这个变量指向我们的函数对象
```
const fn = function() {}
```
那有啥区别呢？实际上解析器在向执行环境中加载数据的时候，对于函数声明和表达式是有着不同的处理规则。解析器会优先读取函数声明，并使其在执行任何代码之前可用或者叫做可访问吧。而表达式则是要等待解析器执行到表达式所在的那一行时，才会被解释执行。

看例子
```
alert(fn)
alert(a)
function fn() {}
a = function() {}
```
结果是fn正常alert，a会报ReferenceError引用错误，因为表达式还没有执行到a被赋值的那一行。思考以下几个情况的返回值

```
# 情况1
alert(fn)
fn()
alert(a)
let a
function fn() {
    a = function() {
        console.log("im a")
    }
}

# 情况2
alert(fn)
fn()
alert(a)
function fn() {
    a = function() {
        console.log("im a")
    }
}

# 情况3
alert(fn)
fn()
alert(a)
function fn() {
    setTimeout(() => {
        a = function() {
            console.log("im a")
        }
    })
}
```

来解释下函数声明和表达式对于解析器为什么会不同对待的原因是什么，解析器在向执行环境加载数据的时候会一个叫做 **"函数声明提升"** 的过程( $function$ $declaration$ $hoisting$ )，读取并将函数声明添加到执行环境中。js引擎会把函数声明的代码放在源代码树的顶部。

---

#### 2. 执行环境及作用域链
