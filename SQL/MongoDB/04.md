## MongoDB - 查询 笔记-04

> ##
> ### 目录
> 1. find简介
> 2. 查询条件
> 3. 特定类型的查询
> 4. $where查询
> 5. 游标(cursor)
> 6. 数据库命令(command)
> ##

---

#### 1. find简介

MongoDB中使用find命令来进行查询，查询本身就是返回一个集合中文档的子集，子集的范围从0到全部集合。find的第一个参数决定了要返回哪些文档，这个参数是一个文档，用于指定查询条件。

<b>查询全部文档</b>
```
database.collection.find({})
```
指定空的文档会匹配集合的全部内容。如果不指定查询文档，默认就是{}。

<b>查询符合指定条件的文档</b>
```
database.collection.find(
    { key: value [, key: value, ...]},
)
```

例如要在users集合中查找name为joe，age为27岁的用户。
```
> use mydatabse
> db.users.find({ "name": "joe", "age": 27 })
```

<b>指定需要返回的键</b>
```
database.collection.find(
    { key: value [, key: value, ...]},
    { key1: 1, key2: 0, ... }
)
```

要求返回即“key: 1”，排除则是"key: 0"，默认情况下"_id"这个键总是被返回的，即便是没有指定要返回这个键。

<b>存在的限制</b>

查询使用上存在一些限制。传递给数据库的查询文档的值必须是常量，也就是说不能引用文档中其他键的值。例如
```
> use database
> db.users.find({ "in_stock": "this.num_sold" })
```
这种方式是行不通的，与其拐弯抹角的写法，更好的方式是调整文档的结构。例如上面的例子中直接调整为"initial_stock"和"in_stock"两个键。这样每当有人购买物品的时候就将"in_stock"减1.这样这要用一个简单查询就知道了哪种商品脱销了。
```
> db.stockRel.find({ "in_stock": 0 })
```

---

#### 2. 查询条件

进阶一下，查询条件还可以匹配更加复杂的条件，譬如范围、OR子句、取反。

<b>比较查询</b>
```
database.collection.find(
    {
        key: {
            condition[$lt|$lte|$gt|$gte|$ne]: val,
            condition1: val,
            condition2: val,
            ...
        }
    }
)
```

例如要查询年龄大于18且小于等于30岁的文档
```
> use myDatabse
> db.users.find({ "age": { "$gt": 18, "$lte": 30 } })
```

这样的比较对于日期范围的查询尤为重要，例如要查询在2022年10月1日前注册的人
```
> use myDatabse
> start = new Date("01/10/2022")
> db.users.find({ "register_datetime": {
    "$lt": start
} })
```
对于日期的精确查询用处不大，因为日期一般都是查询范围很少要精确到时分秒的。

查询某个键值不等于某个特定值的情况可以用$ne操作符，例如查询所有名字不为"joe"的用户
```
> db.users.find({ "name": { "$ne": "joe" } })
```

<b>OR查询</b>
```
database.collection.find(
    {
        key: {
            condition[$or|$in]: val,
            condition1: val,
            condition2: val,
            ...
        }
    }
)
```

$in表示查询一个键的多个值，例如查询用户表中user_id匹配等于123的也会匹配等于joe的用户
```
> db.users.find({ "user_id": { "$in": [123, "joe"] } })
```
如果$in对应的数组只有一个值，那么跟直接匹配这个值的效果一样。即
```
user_id: { $in: [123] }
# 等同于
user_id: 123
```

与之相反的操作符是$nin，表示不再范围内。譬如查询user_id不等于123且不等joe的人
```
> db.users.find({ "user_id": { "$nin": [123, "joe"] } })
```

$or表示在多个键中查询任意的给定值

例如要查询列表中匹配name为joe 和 age为12、18、19岁的用户
```
> db.users.find({
    "$or": [
        { "name": "joe" },
        { "age": { $in: [12, 18, 19] } }
    ]
})
```

<b>$not查询</b>

\$not是元操作符(meta-opreator)，$not符号常用语配合正则使用，用来查找那些与特定模式不匹配的文档。例如要查询用户表中年龄对5取余数不为1的用户
```
> db.users.find({ "age": { "$not": { "$mod": [5, 1] } } })
```

<b>条件语义</b>

之前我们提到过的修改器，会发现以$开头的键位于不同的位置，可以总结为 <b>条件语句是内层文档的键，修改器是外层文档的键</b>。

一个键可以有任意多个条件，但一个键只能有一个修改器。例如一下修改是无意义的
```
{"$inc": { "age": 1 }, "$set": { "age": 23 }}
```

存在一些元操作符是位于外层文档的譬如"\$and"、"\$or"、"\$nor"

---

#### 3. 特定类型的查询

MongoDB的文档可以使用多种类型的数据。其中有一些在查询时有特别的表现。

<b>Null值</b>
null类型的行为又一些奇怪，它确实能匹配自身但还会匹配不包含这个键的文档。

例如
```
> db.users.find({ "sex": null })
{ "_id": ObjectId("..."), "name": "joe" }
{ "_id": ObjectId("..."), "name": "koe" }
{ "_id": ObjectId("..."), "name": "loe" }
```
如果只想匹配键值为null的文档则需要用\$in配合\$exists操作符来实现。
```
> db.users.find({ "sex": { "$in": [null], "$exists": true } })
```

<b>正则表达式</b>

正则表达式能够灵活有效的匹配字符串。
```
database.collection.find({ key: regexp })
```

MongoDB使用Perl兼容的正则表达式（PCRE）库来匹配正则表达式，任何PCRE支持的正则表达式语法都能被MongoDB识别。

<b>查询数组</b>

最普通的用法，是可以像查询标量值一样查询。
```
database.collection.find({ key: value })
```
value会和数组中的每一个值做匹配如果符合则返回对应文档。

+ $all操作符
    >
    使用\$all操作符对数组进行多个元素来匹配。
    ```
    database.collection.find({ key: { "$all": [value, value, ...] } })
    ```
    $all的值对于顺序无要求，举例子说明更加形象，要匹配用户表中爱好包含足球、乒乓球的学生
    >
    正确的用法是
    ```
    > db.users.find({ "hobbit": { "$all": ["football", "pingpang"] } })
    ```

    以下的写法不会成功匹配，因为还有可能有其他爱好，精确匹配无法满足需求
    ```
    > db.users.find({ "hobbit": ["football", "pingpang"] })
    ```
    >
+ 下标查询
    >
    ```
    database.collection.find({ "key.[idx]": value })
    ```

    例如
    ```
    > db.users.find({ "hobbit.0": "swimming" })
    ```

+ $size操作符
    >
    $size用于返回满足数组特定长度的文档
    ```
    database.collection.find({ key: { "$size": length } })
    ```

    例如返回爱好有三个的用户
    ```
    > db.users.find({ "hobbit": { "$size": 3 } })
    ```

    但是\$size不能与条件操作符联合使用，但可以利用一个小技巧来实现，就是自定义一个键size每次向数组添加元素的时候就加1，移除的时候就减1
    ```
    > db.users.update({ "_id": ObjectId(...) }, {
        "$push": { "hobbit": "swimming" },
        "$inc": { "size": 1 }
    })
    > db.users.find({ "size": { "$gt": 3 } })
    ```

+ $slice操作符
    >
    \$slice操作符用于匹配某个键的数组元素的一个子集
    ```
    databse.collection.find(
        { key: value, ... },
        { key: { "$slice": [offset,] [+|-]counts } }
    )
    ```

    例如针对用户评论集合
    ```
    # 返回前10条评论
    > db.userComments.find({}, {
        "comments": { "$slice": 10 }
    })

    # 返回后10条评论
    > db.userComments.find({}, {
        "comments": { "$slice": -10 }
    })

    # 返回从第2条开始到第12条评论，如果不够则返回全部
    > db.userComments.find({}, {
        "comments": { "$slice": [1, 10] }
    })
    ```

    除非特别声明，否则使用$slice的时候会返回<b>所有的键</b>。
    >
+ 返回一个匹配的数组元素
    >
    使用"$"操作符可以得到第一个匹配的元素。
    ```
    database.collection.find({}, { "key.$": 1 })
    ```
    例如
    ```
    > db.userComments.find({ "comments.username": "joe" }, { "comments.$": 1 })
    ```
    会返回comments数组中一条username为joe的评论数据。
    >
+ 数组和范围查询的相互作用
    >
    对于数组来说直接用$gt之类的比较操作符，效率很低，而且往往有些时候还适得其反。例如查询x值介于10～20之间的文档，如果用条件查询
    ```
    > db.col.find({ "x": { "$gt": 10, "$lt": 20 } })
    ```
    这个查询语句会返回非预期的{ "x": [5, 25] }，因为5与"$lt: 20"匹配，25与"$gt: 10"匹配都成功了，所以返回了。

    所以需要用$elemMatch操作符要求使用的范围条件同时生效来对一个数组元素进行比较查询，上面的语句改写为
    ```
    > db.col.find({ "x": { "$elemMatch": { "gt": 10, "$lt": 20 } } })
    ```

    如果需要匹配非数组类型属性的文档，可以使用后面会介绍到的min()和max()函数来将查询条件遍历的索引范围限制为"\$gt"和"\$lt"的值
    ```
    > db.col
    .find({ "x": { "$gt": 10, "$lt": 20 } })
    .min({ "x": 10 })
    .max({ "x": 20 })
    ```
<b>查询内嵌文档</b>

可以进行精确匹配。例如现在有一个用户评论集合，要查询评论name为joe，score为5分的文档（内嵌文档还包含comment属性）
```
> db.userComments.find({ "comments": { "name": "joe", score: 5, comment: "its so cool" } })
```

但实际上往往一个内嵌文档很大，包含的属性很多，不可能查询一次就详尽的罗列所有属性，这时就需要进行部分特定属性的匹配，这样此查询即使未来某个内嵌文档增加了新的属性也不会受到影响（除非删除了特定属性）
```
> db.userComments.find({ "comments.name": "joe", "comments.score": 5 })
```

随着业务的复杂度升级，有一个场景需要我们查询评论分数大于5分的文档，此时对上面的查询语句进行修改
```
> db.userComments.find({ "comments.name": "joe", "comments.score": { "$gt": 5 } })
```
貌似是可行，但很可惜，对于该查询结果满足name为joe，score大于5分的有可能不是同一个文档。

所以需要用到之前操作数组时用到的\$elemMatch命令来进行条件的联合。
```
> db.userComments.find({
    "comments": {
        "$elemMatch": {
            "name": "joe",
            "score": { "$gt": 5 }
        }
    }
})
```

---

#### 4. $where查询
