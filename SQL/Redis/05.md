## Redis-数据类型 笔记-05

> ##
> ### 目录
> 1. 基本操作
> 2. 字符串类型
> 2.1 赋值与取值
> 2.2 递增数字
> 2.3 竞态条件
> 2.4 其他命令
> 3. 散列类型
> 4. 列表类型
> 5. 集合类型
> 6. 有序集合类型
> ##

---

#### 1. 基本操作

获得符合规则的键名规则
```
keys pattern
```
pattern 支持glob风格通配符，规则如下
|符号|含义|
|---|----|
|?|匹配一个字符|
|*|匹配任意字符(包括0个)|
|[]|匹配范围，如[a-z]，表示匹配a-z的字符|
|\x|匹配字符x，用于转义|

设置键值
```
> set bar 1
OK
```

获取键值
```
> get bar
"1"
```

判断键的类型
```
> type bar
string
```

判断键是否存在, 1表示存在, 0表示不存在
```
> exists bar
(integer) 1
```

删除键, 删除成功返回1，键不存在返回0
```
> del bar
(integer) 1
```

小技巧：del命令参数不支持通配符，但我们可以结合Linux的管道和xargs命令，自己实现删除所有符合规则的键。比如删除所有以 user: 开头的键，就可以执行 
    
    redis-cli keys user:* | xargs redis-cli del
    
另外由于del命令支持多个键作为参数，所以还可以执行

    redis-cli del (redis-cli keys user:*)
    
来达到同样效果，但性能更好。

---

#### 2. 字符串类型

字符串类型是Redis中最基本的数据类型，它能存储任何形式的字符串，包括二进制数据。可以用其存储用户的邮箱、JSON化的对象甚至是一张图片。

一个字符串类型键允许存储的数据的最大容量是512MB。

##### 2.1 赋值与取值

语法
```
SET key value
GET key
```

DEMO
```
> set name "joe"
OK
> get name
"joe"
```

当键不存在时会返回空结果。

##### 2.2 递增数字

用法
```
INCR key
```

字符串类型可以存储任何形式的字符串，当存储的字符串是整数形式时，Redis提供了一个实用的命令INCR，其作用是让键值递增。

DEMO
```
> INCR num
(integer) 1
> get num
"1"
```

当键值不是整数时Redis会提示错误
```
> SET foo Lorem
OK
> INCR foo
(err) ERR value is not an integer or out of range
```

##### 2.3 竞态条件

多客户端连接Redis，对同一个key进行修改的时候会出现竞争条件。因为Redis内的所有命令都是原子操作(atomic opreation)，无论多少个客户端同时连接，都不会出现连续误操作的情况。之后的事务(transaction)和脚本(script)可以实现自定义的原子操作。

##### 2.4 其他命令

* 增加指定的整数
    >
    ```
    INCRBY key increment
    ```
    INCRBY命令可以通过increment参数指定一次增加的数值
    >
    DEMO
    ```
    INCRBY foo 99
    ```

* 减少指定的整数
    >
    ```
    DECR key
    DECRBY key decrement
    ```
    用法同INCR
    >
    DEMO
    ```
    DECR foo
    DECR foo 99
    ```

* 增加指定浮点数
    >
    ```
    INCRBYFLOAT key increment
    ```
    用法同INCR
    >
    DEMO
    ```
    INCRBYFLOAT foo 22.22
    ```

* 向尾部追加值
    >
    ```
    APPEND key value
    ```
    APPEND作用是向键值的末尾追加value。如果键不存在则将该键的值设置为value，即相当于 SET key value。返回值是追加后的字符串的长度。
    >
    DEMO
    ```
    > set foo joe
    OK
    > append foo " hi"
    (integer) 6
    > get foo
    "joe hi"
    ```
    添加空格需要将value用双引号括起。
    >

* 获取字符串长度
    >
    ```
    STRLEN key
    ```
    命令会返回键值的长度。如果键不存在则返回0。
    >
    DEMO
    ```
    > STRLEN foo
    (integer) 6
    ```
    
* 同时获得或设置多个键值
    >
    ```
    MGET key [key...]
    MSET key value [key value...]
    ```
    >
    DEMO
    ```
    > mset foo "joe" bar "fizz" zoo "nemo"
    OK
    > mget foo bar zoo
    1) "joe"
    2) "fizz"
    3) "nemo"
    ```

* 位操作
    >
    ```
    # 获取
    GETBIT key offset
    # 设置
    SETBIT key offset value
    # 长度
    BITCOUNT key [start] [end]
    # 位操作
    BITOP opreation destkey key [key...]
    ```
    一个字节由8位二进制组成，Redis提供了以上4个命令，可以直接对二进制进行位操作。
    >
    例如"bar"的二进制"01100010 01100001 01110010"
    >
    GETBIT命令可以获得一个字符串类型键指定位置的二进制位的值(0或1)，索引从0开始
    ```
    > SET foo bar
    OK
    > GETBIT foo 0
    (integer) 0
    > GETBIT foo 9
    (integer) 1
    ```
    如果需要获取的二进制位的索引超出了键值的二进制位则返回0。
    >
    SETBIT命令可以设置字符串类型键指定位置的二进制位的值，返回是该位置的旧值。
    ```
    > SETBIT foo 0 1
    (integer) 0
    ```
    如果设置的键位置超过了键值的二进制位的长度，SETBIT命令会自动将中间的二进制位设置0，同理设置一个不存在的键的指定二进制位的值会自动将其前面的位赋值为0。
    >
    ```
    > SETBIT nofoo 10 1
    (integer) 0
    > GETBIT nofoo 5
    (integer) 0
    ```
    >
    BITCOUNT命令可以获得字符串类型键中值是1的二进制位个数
    ```
    > BITCOUNT foo
    (integer) 14
    ```
    可以通过参数来限制统计的字节范围，如只希望统计前两个字节的
    ```
    > BITCOUNT FOO 0 1
    (integer) 10
    ```
    >
    BITOP命令可以对多个字符串类型键进行位运算，并将结果存储在destkey参数指定的键内。BITOP命令支持运算操作有 AND、OR、XOR、NOT。
    ```
    > SET foo1 bar
    OK
    > SET foo2 baz
    OK
    > BITOP OR res bar baz
    (integer) 3
    > GET res
    "baz"
    ```
    利用位操作命令可以非常紧凑地存储布尔值。比如某个网站的每个用户都有一个递增的整数id，如果使用一个字符串类型键配合位操作来记录每个用户的性别（用户id作为索引，二进制位值1和0表示男女），那么记录100万个用户的性别只需要占用100KB多的空间，而且由于GETBIT和SETBIT的时间复杂度都是O(1)，所以读取的性能很高。
    
---
    
#### 3. 散列类型

我们现在已经知道Redis是采用字典结构以键值对的形式存储数据的，而散列（hash）类型的键值也是一种字典结构，其存储了字段（filed）和字段值的映射，Redis要求映射的值只能是字符串，不支持其它格式，也不支持嵌套。

<b>赋值</b>
```
HSET key field value
```
如果是插入操作返回1，更新操作返回0

DEMO
```
> hset locationMap 1 "china"
(integer) 1
```

<b>批量赋值</b>
```
HMSET key field value [field value ...]
```

DEMO
```
> hmset locationMap 1 "china" 2 "US" 3 "UK"
```

<b>取值</b>
```
HGET key field
```

DEMO
```
> hget locationMap 1
```

<b>批量取值</b>
```
HMGET key field [field ...]
```

DEMO
```
> hmget locationMap 1 2 3
```

<b>完整显示hash表</b>
```
HGETALL key
```

DEMO
```
> hgetall locationMap
```

HSET、HMSET命令不区分插入和更新操作。

提示在Redis中每个键都属于一个明确的数据类型，不能用A类型的赋值命令操作B类型数据。存在特例，SET命令。

<b>判断字段是否存在</b>

```
HEXISTS key field
```

DEMO
```
> hexists locationMap name
(integer) 0
```

存在返回1，否则返回0


<b>当字段不存在时赋值</b>
```
HSETNX key field value
```
HSETNX中的NX代表"IF NOT EXISTS", HSETNX和HSET命令相似，但它是原子级别的不用担心竞态条件。

DEMO
```
> hsetnx locationMap age 20
```

<b>增加数字</b>
```
HINCRBY key field increment
```
用法类似INCRBY，只不过是给hashmap增值

DEMO
```
> hincrby locationMap age 40
```

<b>删除字段</b>
```
HDEL key field [field ...]
```

DEMO
```
> hdel locationMap age
```

<b>只获取字段名或字段值</b>
```
HKEYS key
HVALS key
```

DEMO
```
> hkeys locationMap
> hvals locationMap
```

<b>获得字段数量</b>
```
HLEN key
```

DEMO
```
> hlen locationMap
```

---

#### 4. 列表类型
