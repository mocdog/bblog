## 操作系统导论 - PART1 虚拟化

## 抽象-进程 笔记-02

这里集中讨论下操作系统提供的基本抽象 - 进程。进程的非正式定义很简单：进程就是运行中的程序。程序本身是没有生命周期的，只是存在磁盘上的一些指令（也可能是一些静态数据）。是操作系统让这些字节运行起来，让程序发挥作用。

---

#### 时分共享 ($time$ $sharing$)

操作系统通过虚拟化CPU来提供这种假象。通过让一个进程只运行一个事件片，然后切换到其他进程，操作系统提供了存在许多个虚假CPU的假象。这就叫时分共享CPU技术。允许用户如愿的运行多个并发进程。

时分共享是操作系统共享资源所使用的最基本的技术之一。通过允许资源由一个实体使用一小段时间，然后由另一个实体使用一小段时间，如此下去，所谓的资源可以被许多人共享。

---

#### 空分共享 ($space$ $sharing$)

时分共享与之对应的是空分共享，指资源在空间上被划分给希望使用它的人。如磁盘就是一个空分共享资源，因为一旦将块分给文件，用户删除文件之前，都不可能将其分配给其他文件。

---

#### 地址空间 (address space)

进程可以访问的内存称为地址空间，它是进程的一部分。

---

#### 寄存器

进程的机器状态，许多指令明确的读取或更新寄存器。

存在一些特殊的寄存器。例如，程序计数器（Program Counter，PC；有时称为指令指针，Instruction Pointer，IP），它告诉我们当前程序正在执行哪个指令；栈指针（Stack Pointer）和相关的帧指针（frame pointer）用于管理函数参数栈、局部变量和返回地址。

---

#### 区分理解策略和机制

许多操作系统中，一个通用的设计规范是将 **高级策略** 和 **低级机制** 区分开。机制可以理解为系统对“how”问题提供应对解决路径。策略可以理解为系统对“which”问题，在诸多可选方案下，提供最优解。

将两者分开可以轻松改变策略，而不用重新考虑机制，这是一种模块(modularity)的形式，一种通用的软件设计原则。

---

#### 进程API

所有现代操作系统都会提供相应的API来实现对进程的操作

+   创建
+   销毁：大多进程运行完成后，会自动退出，某些场景会需要手动进行进程销毁
+   等待：控制进程进入等待状态(pending)。
+   其他控制：例如暂停进程，然后恢复。
+   查询状态

---

#### 进程创建细节

操作系统运行程序时，先将代码和所有静态数据加载到内存中，加载到进程的地址空间。程序最初以某种可执行格式驻留在磁盘上（disk或基于内存的SSD上）。因此，将程序和静态数据加载到内存中的过程，需要操作系统从磁盘读取这些字节，并将它们放在内存中的某处。

将程序的代码和静态数据加载到内存，在现代操作系统用的都是懒加载的方式在运行时所需，就从硬盘调取对应程序字节到内存。然后为程序运行时栈（runtime stack）申请分配些内存。操作系统也可能使用参数初始化栈。例如C会将参数填入main函数，即argv和argc数组。

操作系统也可能为程序的堆（heap）分配些内存。在c中，堆用于显示请求的动态分配数据。程序通过``malloc()``来请求空间，用``free()``来释放。

数据结构（如链表、散列表、树等）需要堆。起初堆可能很小。随着程序运行，通过``malloc()``来申请开辟更多内存空间。操作系统会根据目前的内存使用情况或多或少的分配给进程，以满足这些调用。

操作系统还会执行一些其他初始化任务，特别是输入/输出相关的任务。例如Unix系统中，默认每个进程都会有3个打开的文件描述符（file descriptor）用于标准输入、输出、错误。

完成以上步骤，遂即启动程序。OS将CPU的控制权转让给新创建的进程，从而程序开始执行。

---

#### 进程状态

进程状态有三种， 分别是就绪、运行、阻塞态。

三种状态的切换是通过调度程序来完成的。切换的时候会转换上下文(context)，所以是存在切换成本的，不同操作系统的调度程序实现所运用的算法不尽相同，所以之后会专门介绍进程状态及调度算法。

---

#### 数据结构-进程列表

操作系统充满了各种重要的数据结构（data structure）。进程列表（process list）是第一个这样的结构。存储关于进程的信息个体结构称为进程控制块（Process Control Block，PCB），这是包含每个进程信息的C结构的一种方式。
